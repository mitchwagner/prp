* May 3, 2018
- We recently came to the conclusion that I have been treating interactome
  and pathway edges as directed incorrectly. The problem is that all edges
  are seen as directed edges at present (undirected edges are converted to
  two directed edges). Thus, it is incorrect for me to include one half of
  an undirected edge's directed counterparts in the set of positives and the
  other in a set of negatives

- Thus, I started working on remedying this, by separating directed edges from
  undirected edges until necessary. This provided the impetus to update the
  interactome version we are using, along with the pathways.
    
    - The plan to fix this:
        - 1) Keep, for both a pathway and an interactome, a graph of
             directed edges and  graph of undirected edges

        - 2) Create folds using the directed and undirected versions 
             separately

        - 3) Create a directed version of the interactome and use the folds
             to run RWER.

        - 4) The RESULTING and FINAL FOLDS are directed versions of the 
             original folds, except undirected edges only have a single
             direction included (the direction that got the highest flux)

        - To put this another way:
            - I create directed train positives from the pathway
            - I create undirected train positives from the pathway
            - I create directed test positives from the pathway
            - I create undirected test positives from the pathway
                - From these, I create: 
                    - merged pathway positives graph (all edges are directed)
                    - merged pathway negatives graph (all edges are directed)

            - I create directed train negatives from the interactome 
            - I create undirected train negatives from the interactome 
            - I create directed test negatives from the interactome 
            - I create undirected test negatives from the interactome 
                - From these, I create: 
                    - merged interactome positives graph
                    - merged interactome negatives graph

            - Then, I create a merged interactome and run RWER on it using the
              merged train positives from the pathway

            - Then, for each merged graph:
                - Look at the undirected graph that comprised part of its 
                  input
                    - For each edge in this graph, look up the edge flux
                      from the RWER in the merged interactome

                        - Delete the directed edge created from this undirected
                          edge that has the lower flux

            - This results in four merged graphs. These graphs form the 
              input to the algorithms and precision/recall

        - Note that this WOULD prevent us from doing certain edge selection
          techniques. E.g., if we wanted folds based in paths as opposed to the
          selection of individual components. We can separate undirected edges
          from directed edges as long as the fold generation does not need to
          consider the dependencies between the two.

    - Interactome: 
        - I am now using Jeff's 2018_01 version of the interactome. I obtain
          edge directionality (directed or undirected, that is) by looking at
          the interactome's evidence file.
    
    - Pathways:
        - At first, Jeff suggested I extract the NetPath pathways from the 
          interactome's evidence file. I did this first. Note that this does
          NOT take into account that an pathway's undirected edge could
          be trumped by a directed edge from a different evidence source.
            
            - NOTE: TAKING DIRECTIONALITY FROM THE EVIDENCE FILE HAS A 
              HIDDEN DANGER. This is because we do not USE all evidences in
              the interactome itself. This means that if a line in the 
              evidence file lists an edge as directed, the interactome itself
              could still have been built using that edge as UNdirected.
                - I discussed this with Jeff. We noted 71 such cases, from
                  MINT. He decided to just add these edges back to the 
                  interactome.
        
            - When I tried to S-T prune these pathways, I wound up with several
              pathways being absolutely decimated. I realized that I was again
              interpreting the edges in the resulting pathway as directed
              instead of undirected. I then altered the pathway file to include
              both directions explicitly to remedy this, but the results were
              similar: the pathways were decimated

        - Thus, I now turn to the original SBML files once more. The parsed
          versions that I have been using has an edge_type column that I can
          use to determine the directionality.
            - The current plan is to re-parse the parsed "-edges.txt" files
              derived from SBML, then add them to the evidence file,
              then create a new interactome, then use that interactome to 
              inform the directionality of the "-edges.txt" files
            
            - I do not want to have any conflicts between the pathways and
              the interactome in terms of direction. There are four cases: 

                1) NetPath says an edge is directed, interactome agrees 
                2) NetPath says an edge is undirected, interactome agrees 
                3) NetPath says an edge is directed, interactome disagrees
                4) NetPath says an edge is undirected, interactome disagrees

                - The first two cases are not problems. 

                - The third case can be ammeliorated by including the NetPath
                  SBML files in the evidence file and re-weighting the
                  interactome

                - The final case is the annoying one. It's not a terrible
                  problem because I can just say that the resulting fold
                  direction is the one the interactome already has.

                - Either way, I would prefer to start out with the pathway
                  as a strict subset of the interactome.

        - I do not think the S-T pruning should be a problem because if
          one edge in an undirected edge pair is on an S-T path, the other 
          direction has to be as well. 
  
* March 7, 2018
- After consulting with Murali and Aditya, I removed the second entry for
  P19838 in the EGFR node file (the row that has its type listed as "none").

* February 22, 2018
- QuickLinkerConcat has some subtle errors due to floating point.
  In this algorithm, we combine the results for multiple regular expressions,
  concatenating one set after another. When we aggregate over folds, we
  use the cost/score associated with each row to re-rank the rows, and then
  use the resulting ranked rows to calculate precision/recall. To prioritize
  one regex's results before all the others (even across folds), we add 
  a number to this score for each row before aggregation (for 3 regexes, the
  first gets + 2, the second gets + 1, the third gets + 0).

  By adding to the floating point numbers, due to rounding error, floating
  points numbers that were only very slightly different before the addition
  might get the same rank after the addition. In other words, 1 + x = 1 + y

* February 19, 2018
- I learned today that the node file for EGFR has the same protein
  listed TWICE: that protein is P19838. One row has it as a TF, and
  one has it as none. I am not sure what to do here, and need to ask
  Murali about this. If it is meant to be a TF, it is getting messed 
  up in my pipeline currently, which assumes that each node is listed
  only ONCE in the node file.

* January 24, 2018
- Today, while creating an interactome by adding missing edges from the 
  Netpath pathways, I noticed that, similar to the Kit pathway (see
  January 9) TCR and the TGF_beta_receptor pathway have nodes named "-".
  For now, this is mostly just an annoyance, but it does mean the scripts
  for posting to GraphSpace might be slightly incorrect. 

  I also don't have a good idea of what these nodes are supposed to be.

* January 23
- In our last meeting, we discussed the possibility that we where maybe 
  not thinking our precision/recall calculation through. In particular, each
  fold consists of a list of positives and negatives to train on. However,
  when we run the algorithm all the negatives (those in the fold and those 
  not in the fold) are given the label n (as are the test positives), 
  while the list of training positives are given the label p.

  After discussing for a while, we decided that we would probably not improve
  precision/recall by labeling training edges with a different label, like "x".
  This is 1) because you might need to go through an "x" to get to a "p"
  anyway, and 2) we aren't using the "x"s in the calculation of a particular
  fold anyway.


* January 10, 2018
- I emailed one of the original authors of FAdo asking their thoughts on the
  .tablereg file. 

* January 9, 2018
- I found an edge in the KitReceptor pathway nodes/edges file that Anna used.
  The name of this node was "--" and in the node file, it had no node type.  I
  am changing the name of this node to comply with Jeff's GraphSpace posting
  script, which identifies the nodes in an edge by the delimiting character
  "-".

- I also found a file, .tablereg, which seems to have been left by FAdo.  I did
  a search on Google, and I found a GitHub repository for FAdo. I'm not sure if
  it is the original repository for FAdo or not (pypi would seem to indicate
  otherwise). Regardless, I left an issue:

  https://github.com/Glavin001/FAdo/issues/3

  For now, I am operating under the assumption that this file is not that
  important and shouldn't pose a threat to parallelization. This could be an
  erroneous assumption.

- Update: The author of the repo actually got back to me fairly quickly. While
  he is not the original author, he looked into the code and does believe the
  code could be problematic if parallelized. 

* October 19, 2017
- The old PathLinker script in Anna's directory, by default, divided all edge
  weights by the sum of the weight of all edges. If you think about it, this
  minimizes the any importance of edge weight at all, given the negative log
  transform of edge weights. By removing the depedence of the master script on
  the EXACT version Anna was referencing, I've removed the ability to
  automatically recreate this effect.

  If you want to recreate this parameter, you can now pass a very large value
  for the edge penalty to PathLinker. However, at the moment, the ability to
  pass an edge penalty is not possible in our master script. It might be
  worthwhile to write some sort of JSON config file parser that reads in
  parameters for every algorithm. It's getting to the point where the user is
  absolutely inundated with switches to provide the program.

* September 27, 2017
- I refactored the minimum cut computation in the main PathLinker script. One
  possibly important change is that before, it was only being run if the
  directory did not already exist. I decided to eschew this notion, and always
  recompute it, because we didn't have checks on if the parameters themselves
  were actually changing.
